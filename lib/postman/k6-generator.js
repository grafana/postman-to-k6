var RequestBodyModes = require('postman-collection').RequestBody.MODES,
    ItemGroup = require('postman-collection').ItemGroup,
    Item = require('postman-collection').Item,
    K6Helper = require('../k6-helper'),
    util = require('util');

function K6Generator() {
}

K6Generator.prototype = {


  _convertCollection: function(item, result, allVariables) {

    var self = this;

    if (ItemGroup.isItemGroup(item)) {
      var folder = item;
      if (folder.auth) { throw new Error(' TODO: folder.auth'); }

      result.push('');
      result.push(util.format("  group(\"%s\", function() {\n", folder.name));

      result.push("    let res;");

      folder.items.each(function(folderItem, index) {
        self._convertCollection(folderItem, result, allVariables);
      });

      result.push("  });\n");

    } else if (Item.isItem(item)) {

      k6Request = convertToK6Request(item);

      if (k6Request.variables) {
        k6Request.variables.forEach(function(item) {
          allVariables.push(item);
        });
      }
      result.push(k6Request.result);

    } else {

      throw new Error(' TODO: Implement postCollection item');

    }

  },


  convert: function(postmanCollection) {

    if (!postmanCollection || postmanCollection.items.count() === 0 ) {
      return '// No HTTP/HTTPS transactions have been recorded.';
    }

    const MAX_REDIRECTS = 4;

    var result = [],
        folderRequests,
        requests = [],
        allVariables = [],
        k6Request,
        self = this;


    result.push(util.format("// Auto-generated by the Load Impact converter"));
    result.push("");
    result.push("import { group } from \"k6\";");
    result.push("import http from \"k6/http\";")
    result.push("");
    result.push("export let options = {");
    result.push(util.format("  maxRedirects: %s", MAX_REDIRECTS));
    result.push("}");
    result.push("");

    result.push("export default function() {");

    var hasRequestsAtRootLevel = false;
    postmanCollection.items.each(function(item) {
      if (Item.isItem(item)) {
        hasRequestsAtRootLevel = true;
      }
    });

    if (hasRequestsAtRootLevel) {
      result.push("    let res;");
    }

    postmanCollection.items.each(function(item) {

      self._convertCollection(item, result, allVariables);

    });

    if (allVariables.length) {

      allVariables = arrayUnique(allVariables);

      result.splice(4, 0, "");
      for (var j = allVariables.length - 1; j >= 0; j--) {

        result.splice(4, 0, util.format("env['%s'] = \"YOUR_VALUE\";", allVariables[j]));

      }
      result.splice(4, 0, "\nlet env = {};");

    }

    result.push("}");

    return result.join('\n');

  }

};
function arrayUnique(array) {
    var a = array.concat();
    for(var i=0; i<a.length; ++i) {
        for(var j=i+1; j<a.length; ++j) {
            if(a[i] === a[j])
                a.splice(j--, 1);
        }
    }

    return a;
}



function convertToK6Request(item) {

  var request = item.request,
      body = request.body,
      method,
      url,
      data,
      postRequest,
      preRequest,
      auth = request.auth,
      headerHash = {},
      authHeader,
      headers = [];


  // read method & url
  method = request.method;
  url = request.url.toString();


  // read test and preRequest functions
  if (item.events.count() > 0) {

    item.events.each(function(event) {
      var script;
      if (event.listen === 'test') {
        script = event.script.exec;
        if (script.length) {
          //js commented
          postRequest = util.format("\n    /**\n    %s\n    **/\n", script.join('\n    '));
        }
      } else if (event.listen === 'prerequest') {
        script = event.script.exec;
        if (script.length) {
          //jscommented
          preRequest = util.format("\n    /**\n    %s\n    **/\n", script.join('\n    '));
        }
      }
    });

  }


  // get headers & auth into headerHash
  request.headers.each(function(header) {
    headerHash[header.key] = header.value;
  });

  // add or overwrite auth header
  if (auth && auth.type) {

    var AuthenticationManager = moduleExist('./auth/' + auth.type);
    if (AuthenticationManager && AuthenticationManager.enabled) {

      authHeader = AuthenticationManager.header(request);

      // convert headerHash to arrayHeaders
      if (authHeader) {
        delete headerHash.Authorization;
        headers.push(authHeader);
      }
    } else {

      var authenticationComment;
      if (auth.type === 'awsv4' || auth.type === 'hawk' || auth.type === 'oauth1') {

        authenticationComment = util.format("Note: %s dynamic authentication is not supported", auth.type);

      } else if (auth.type === 'digest') {

        authenticationComment = util.format("Note: %s dynamic digest authentication is not supported", auth.type);

      }

      if (authenticationComment) {

        postRequest = postRequest || '';
        postRequest += util.format("    /** \n    %s\n    **/\n", authenticationComment);

      }


    }
  }


  Object.keys(headerHash).forEach(function(key) {
    var tmpHeader = util.format("\"%s\" : \"%s\"", key, K6Helper.escapeContent(headerHash[key]));
    headers.push(tmpHeader);
  });


  // read body
  var bodyData = body[body.mode];
  if (bodyData) {

    if (body.mode === RequestBodyModes.raw) {
      data = K6Helper.escapeContent(bodyData);
    } else if (bodyData.count() > 0) {
      //body.mode === RequestBodyModes.formdata
      //body.mode === RequestBodyModes.urlencoded
      //should we add default CONTENT-TYPE Header `application/x-www-form-urlencoded`?

      var params = [];
      bodyData.each(function(paramItem) {
        params.push(util.format('%s=%s', encodeURIComponent(paramItem.key), encodeURIComponent(paramItem.value)));
      });

      data = params.join('&');

    }

  }

  return K6Helper.buildK6Request({
    url: url,
    method: method,
    headers: headers,
    data: data,
    preRequest: preRequest,
    postRequest: postRequest,
    variable: 'res'
  });

}

function moduleExist(name){
  try { return require(name); }
  catch(e) { return false; }
}


module.exports = K6Generator;
