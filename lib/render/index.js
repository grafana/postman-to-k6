const aid = require('../aid');
const imports = require('./imports');
const prettier = require('prettier');
const requestImports = require('./request');
const { basename } = require('path');
const { VariableType } = require('../enum');

const empty = '// No HTTP/HTTPS transactions have been recorded';

function render(result) {
  if (!result.main.length) {
    return [empty, {}];
  }
  const raw = [
    header(),
    imps(result),
    options(result),
    data(result),
    initial(result),
    files(result),
    handleSummary(result),
    logic(result),
  ]
    .filter(section => section)
    .join('\n\n');
  const main = prettier.format(raw, { semi: true, parser: 'babel' });
  return [main, result.requests];
}

function header() {
  return '// Auto-generated by the postman-to-k6 converter';
}

function imps(result) {
  return [polyfills(result), imports(result), requestImports(result.requests)]
    .filter(section => section)
    .join('\n');
}

function polyfills(result) {
  return [...result.polyfills]
    .map(name => `import "./libs/${name}.js";`)
    .join('\n');
}

function options(result) {
  if (result.iterations > 1) {
    result.options.iterations = result.iterations;
  }
  if (!Object.keys(result.options).length) {
    return null;
  }
  return `export let options = ${JSON.stringify(result.options)};`;
}

function data(result) {
  if (!result.data.path) {
    return null;
  }
  const parse = dataParse(result);
  const sections = [];
  sections.push(`const file = (() => {
  // Load data file
  const text = open(${JSON.stringify(result.data.path)});
  const rows = ${parse};
  return rows;
})();`);
  if (result.iterations === null) {
    sections.push('options.iterations = file.length;');
  }
  return sections.join('\n');
}

function dataParse(result) {
  switch (result.data.type) {
    case 'csv':
      return 'papaparse.parse(text, { header: true }).data';
    case 'json':
      return 'JSON.parse(text)';
    default:
      throw new Error(`Unrecognized data file type: ${result.data.type}`);
  }
}

function initial(result) {
  const lines = [];
  if (iterationMessage(result)) {
    lines.push('const Iteration = Symbol.for("iteration");');
  }
  for (const [name, label] of result.symbols) {
    lines.push(`const ${name} = Symbol.for(${JSON.stringify(label)});`);
  }
  lines.push('const Request = Symbol.for("request");');
  const initial = [
    'options',
    globalScope(result),
    collectionScope(result),
    environmentScope(result),
    dataScope(result),
  ].filter(item => item);
  const args = initialArgs(initial);
  lines.push(`postman[Symbol.for("initial")](${args});`);
  return lines.join('\n');
}

function globalScope(result) {
  if (result.scope.global.size) {
    return `global: ${vars(result.scope.global)}`;
  } else {
    return null;
  }
}

function collectionScope(result) {
  if (result.scope.collection.size) {
    return `collection: ${vars(result.scope.collection)}`;
  } else {
    return null;
  }
}

function environmentScope(result) {
  if (result.scope.environment.size) {
    return `environment: ${vars(result.scope.environment)}`;
  } else {
    return null;
  }
}

function dataScope(result) {
  if (result.data.path) {
    return 'data: file';
  } else {
    return null;
  }
}

function initialArgs(initial) {
  if (initial.length) {
    return `{
${aid.indent(initial.join(',\n'))}
}`;
  } else {
    return '';
  }
}

function vars(spec) {
  const items = [];
  for (const item of spec) {
    if (item[1] === undefined) {
      continue;
    }
    const name = JSON.stringify(item[0]);
    const value = varValue(item[1]);
    items.push(`${name}: ${value}`);
  }
  return `{
${aid.indent(items.join(',\n'))}
}`;
}

function varValue(spec) {
  switch (spec.type) {
    case VariableType.Boolean:
    case VariableType.Number:
    case VariableType.Literal:
      return spec.value;
    case VariableType.Json:
    case VariableType.String:
      return JSON.stringify(spec.value);
    default:
      throw new Error(`Unrecognized variable type: ${spec.type}`);
  }
}

function files(result) {
  if (result.files.size) {
    const items = [];
    for (const path of result.files) {
      items.push(fileLoad(path));
    }
    return `const files = {};
${items.join('\n')}`;
  } else {
    return null;
  }
}

function fileLoad(path) {
  const name = basename(path);
  return `files[${JSON.stringify(path)}] = http.file(
  open(${JSON.stringify(path)}, "b"),
  ${JSON.stringify(name)}
);`;
}

function handleSummary(result) {
  if (result.handleSummary && result.handleSummary.length > 0) {
    return `export function handleSummary(data) {
  console.log('Preparing the end-of-test summary: ');
  return {
  ${aid.indent(result.handleSummary.join(',\n'))}
  }
}
`;
  }
}

function logic(result) {
  return `export default function() {
${aid.indent(outer(result))}
}
`;
}

function outer(result) {
  return [
    declares(result),
    iteration(result),
    enter(result),
    main(result),
    exit(result),
  ]
    .filter(section => section)
    .join('\n\n');
}

function body(spec, result) {
  return [declares(spec), enter(spec), main(spec, result), exit(spec)]
    .filter(section => section)
    .join('\n\n');
}

function declares(spec) {
  if (!spec.declares.size) {
    return null;
  }
  return `let ${[...spec.declares].join(', ')};`;
}

function enter(spec) {
  const sections = [];
  if (spec.pre) {
    sections.push(`postman[Pre].push(() => {
${aid.indent(spec.pre)}
});`);
  }
  if (spec.post) {
    sections.push(`postman[Post].push(() => {
${aid.indent(spec.post)}
});`);
  }
  if (sections.length) {
    return sections.join('\n');
  } else {
    return null;
  }
}

function exit(spec) {
  const sections = [];
  if (spec.pre) {
    sections.push('postman[Pre].pop();');
  }
  if (spec.post) {
    sections.push('postman[Post].pop();');
  }
  if (sections.length) {
    return sections.join('\n');
  } else {
    return null;
  }
}

function iteration(result) {
  if (iterationMessage(result)) {
    return 'postman[Iteration]();';
  } else {
    return null;
  }
}

function iterationMessage(result) {
  return !!result.data.path;
}

function main(spec, result = spec) {
  const separator = '\n'.repeat(result.setting.separate ? 1 : 2);
  return spec.main.map(item => chunk(item, result)).join(separator);
}

function chunk(item, result) {
  if (!item) {
    return '';
  }
  const type = typeof item;
  switch (type) {
    case 'string':
      return item;
    case 'object':
      if (Array.isArray(item)) {
        return item.join('\n');
      } else {
        return group(item, result);
      }
    default:
      throw new Error('Invalid chunk type: ' + type);
  }
}

function group(spec, result) {
  return `group(${JSON.stringify(spec.name)}, function () {
${aid.indent(body(spec, result))}
});`;
}

module.exports = render;
