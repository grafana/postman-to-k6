const aid = require('../aid')
const classifyImports = require('./classify')
const imports = require('./imports')
const buildCompat = require('../build')
const prettier = require('prettier')
const requestImports = require('./request')
const { VariableType } = require('../enum')

const empty = `// No HTTP/HTTPS transactions have been recorded`

async function render (result) {
  if (!result.main.length) {
    return {
      main: empty,
      requests: {},
      compat: null
    }
  }
  const [ nativeImports, compatImports ] = classifyImports(result)
  const raw = [
    header(),
    imps(result, nativeImports, compatImports),
    options(result),
    data(result),
    initial(result),
    logic(result)
  ].filter(section => section).join(`\n\n`)
  const main = prettier.format(raw, { semi: true, parser: 'babel' })
  const compat = await buildCompat(
    result.polyfills,
    result.bundles,
    compatImports
  )
  return { main, requests: result.requests, compat }
}

function header () {
  return `// Auto-generated by the Load Impact converter`
}

function imps (result, native, compat) {
  return [
    imports(result, native, compat),
    requestImports(result.requests)
  ].filter(section => section).join(`\n`)
}

function options (result) {
  if (result.iterations > 1) {
    result.options.iterations = result.iterations
  }
  if (!Object.keys(result.options).length) {
    return null
  }
  return `export let options = ${JSON.stringify(result.options)};`
}

function data (result) {
  if (!result.data.path) {
    return null
  }
  const parse = dataParse(result)
  const sections = []
  sections.push(`const file = (() => {
  // Load data file
  const text = open(${JSON.stringify(result.data.path)});
  const rows = ${parse};
  return rows;
})();`)
  if (result.iterations === null) {
    sections.push(`options.iterations = file.length;`)
  }
  return sections.join(`\n`)
}

function dataParse (result) {
  switch (result.data.type) {
    case 'csv':
      return `papaparse.parse(text, { header: true }).data`
    case 'json':
      return `JSON.parse(text)`
    default:
      throw new Error(`Unrecognized data file type: ${result.data.type}`)
  }
}

function initial (result) {
  const lines = []
  if (iterationMessage(result)) {
    lines.push(`const Iteration = Symbol.for("iteration");`)
  }
  for (const [ name, label ] of result.symbols) {
    lines.push(`const ${name} = Symbol.for(${JSON.stringify(label)});`)
  }
  lines.push(`const Request = Symbol.for("request");`)
  const initial = [
    `options`,
    globalScope(result),
    collectionScope(result),
    environmentScope(result),
    dataScope(result)
  ].filter(item => item)
  const args = initialArgs(initial)
  lines.push(`postman[Symbol.for("initial")](${args});`)
  return lines.join(`\n`)
}

function globalScope (result) {
  if (result.scope.global.size) {
    return `global: ${vars(result.scope.global)}`
  } else {
    return null
  }
}

function collectionScope (result) {
  if (result.scope.collection.size) {
    return `collection: ${vars(result.scope.collection)}`
  } else {
    return null
  }
}

function environmentScope (result) {
  if (result.scope.environment.size) {
    return `environment: ${vars(result.scope.environment)}`
  } else {
    return null
  }
}

function dataScope (result) {
  if (result.data.path) {
    return `data: file`
  } else {
    return null
  }
}

function initialArgs (initial) {
  if (initial.length) {
    return `{
${aid.indent(initial.join(`,\n`))}
}`
  } else {
    return ``
  }
}

function vars (spec) {
  const items = []
  for (const item of spec) {
    if (item[1] === undefined) {
      continue
    }
    const name = JSON.stringify(item[0])
    const value = varValue(item[1])
    items.push(`${name}: ${value}`)
  }
  return `{
${aid.indent(items.join(`,\n`))}
}`
}

function varValue (spec) {
  switch (spec.type) {
    case VariableType.Boolean:
    case VariableType.Number:
    case VariableType.Literal:
      return spec.value
    case VariableType.Json:
    case VariableType.String:
      return JSON.stringify(spec.value)
    default:
      throw new Error(`Unrecognized variable type: ${spec.type}`)
  }
}

function logic (result) {
  return `export default function() {
${aid.indent(outer(result))}
}
`
}

function outer (result) {
  return [
    declares(result),
    iteration(result),
    enter(result),
    main(result),
    exit(result)
  ].filter(section => section).join(`\n\n`)
}

function body (spec, result) {
  return [
    declares(spec),
    enter(spec),
    main(spec, result),
    exit(spec)
  ].filter(section => section).join(`\n\n`)
}

function declares (spec) {
  if (!spec.declares.size) {
    return null
  }
  return `let ${[ ...spec.declares ].join(`, `)};`
}

function enter (spec) {
  const sections = []
  if (spec.pre) {
    sections.push(`postman[Pre].push(() => {
${aid.indent(spec.pre)}
});`)
  }
  if (spec.post) {
    sections.push(`postman[Post].push(() => {
${aid.indent(spec.post)}
});`)
  }
  if (sections.length) {
    return sections.join(`\n`)
  } else {
    return null
  }
}

function exit (spec) {
  const sections = []
  if (spec.pre) {
    sections.push(`postman[Pre].pop();`)
  }
  if (spec.post) {
    sections.push(`postman[Post].pop();`)
  }
  if (sections.length) {
    return sections.join(`\n`)
  } else {
    return null
  }
}

function iteration (result) {
  if (iterationMessage(result)) {
    return `postman[Iteration]();`
  } else {
    return null
  }
}

function iterationMessage (result) {
  return !!result.data.path
}

function main (spec, result = spec) {
  const separator = `\n`.repeat(result.setting.separate ? 1 : 2)
  return spec.main.map(item => chunk(item, result)).join(separator)
}

function chunk (item, result) {
  if (!item) {
    return ``
  }
  const type = typeof item
  switch (type) {
    case 'string':
      return item
    case 'object':
      if (Array.isArray(item)) {
        return item.join(`\n`)
      } else {
        return group(item, result)
      }
    default:
      throw new Error('Invalid chunk type: ' + type)
  }
}

function group (spec, result) {
  return `group(${JSON.stringify(spec.name)}, function () {
${aid.indent(body(spec, result))}
});`
}

module.exports = render
