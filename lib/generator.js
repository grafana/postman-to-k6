var RequestBodyModes = require('postman-collection').RequestBody.MODES
var ItemGroup = require('postman-collection').ItemGroup
var Item = require('postman-collection').Item
var Helper = require('./helper')
var util = require('util')

function K6Generator () {
}

K6Generator.prototype = {

  _convertCollection: function (item, result, allVariables) {
    var self = this

    if (ItemGroup.isItemGroup(item)) {
      var folder = item
      if (folder.auth) { throw new Error(' TODO: folder.auth') }

      result.push('')
      result.push(util.format('  group("%s", function() {\n', folder.name))

      result.push('    let res;')

      folder.items.each(function (folderItem, index) {
        self._convertCollection(folderItem, result, allVariables)
      })

      result.push('  });\n')
    } else if (Item.isItem(item)) {
      var k6Request = convertToK6Request(item)

      if (k6Request.variables) {
        k6Request.variables.forEach(function (item) {
          allVariables.push(item)
        })
      }
      result.push(k6Request.result)
    } else {
      throw new Error(' TODO: Implement postCollection item')
    }
  },

  convert: function (postmanCollection) {
    if (!postmanCollection || postmanCollection.items.count() === 0) {
      return '// No HTTP/HTTPS transactions have been recorded.'
    }

    const MAX_REDIRECTS = 4

    var result = []

    var allVariables = []

    var self = this

    result.push(util.format('// Auto-generated by the Load Impact converter'))
    result.push('')
    result.push('import { group } from "k6";')
    result.push('import http from "k6/http";')
    result.push('')
    result.push('export let options = {')
    result.push(util.format('  maxRedirects: %s', MAX_REDIRECTS))
    result.push('}')
    result.push('')

    result.push('export default function() {')

    var hasRequestsAtRootLevel = false
    postmanCollection.items.each(function (item) {
      if (Item.isItem(item)) {
        hasRequestsAtRootLevel = true
      }
    })

    if (hasRequestsAtRootLevel) {
      result.push('    let res;')
    }

    postmanCollection.items.each(function (item) {
      self._convertCollection(item, result, allVariables)
    })

    if (allVariables.length) {
      allVariables = arrayUnique(allVariables)

      result.splice(4, 0, '')
      for (var j = allVariables.length - 1; j >= 0; j--) {
        result.splice(4, 0, util.format('let %s = "YOUR_VALUE";', allVariables[j]))
      }
      result.splice(4, 0, '')
    }

    result.push('}')

    return result.join('\n')
  }

}

function arrayUnique (array) {
  var a = array.concat()
  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) { a.splice(j--, 1) }
    }
  }

  return a
}

function convertToK6Request (item) {
  var request = item.request
  var body = request.body
  var method
  var url
  var data
  var postRequest
  var preRequest
  var auth = request.auth
  var headerHash = {}
  var authHeader
  var headers = []

  // read method & url
  method = request.method
  url = request.url.toString()

  // read test and preRequest functions
  if (item.events.count() > 0) {
    item.events.each(function (event) {
      var script
      if (event.listen === 'test') {
        script = event.script.exec
        if (script.length) {
          // js commented
          postRequest = util.format('\n    /**\n    %s\n    **/\n', script.join('\n    '))
        }
      } else if (event.listen === 'prerequest') {
        script = event.script.exec
        if (script.length) {
          // jscommented
          preRequest = util.format('\n    /**\n    %s\n    **/\n', script.join('\n    '))
        }
      }
    })
  }

  // get headers & auth into headerHash
  request.headers.each(function (header) {
    headerHash[header.key] = header.value
  })

  // add or overwrite auth header
  if (auth && auth.type) {
    var AuthenticationManager = moduleExist('./auth/' + auth.type)
    if (AuthenticationManager && AuthenticationManager.enabled) {
      authHeader = AuthenticationManager.header(request)

      // convert headerHash to arrayHeaders
      if (authHeader) {
        delete headerHash.Authorization
        headers.push(authHeader)
      }
    } else {
      var authenticationComment
      if (auth.type === 'awsv4' || auth.type === 'hawk' || auth.type === 'oauth1') {
        authenticationComment = util.format('Note: %s dynamic authentication is not supported', auth.type)
      } else if (auth.type === 'digest') {
        authenticationComment = util.format('Note: %s dynamic digest authentication is not supported', auth.type)
      }

      if (authenticationComment) {
        postRequest = postRequest || ''
        postRequest += util.format('    /** \n    %s\n    **/\n', authenticationComment)
      }
    }
  }

  Object.keys(headerHash).forEach(function (key) {
    var tmpHeader = util.format('"%s" : "%s"', key, Helper.escapeContent(headerHash[key]))
    headers.push(tmpHeader)
  })

  // read body
  var bodyData = body[body.mode]
  if (bodyData) {
    if (body.mode === RequestBodyModes.raw) {
      data = Helper.escapeContent(bodyData)
    } else if (bodyData.count() > 0) {
      // body.mode === RequestBodyModes.formdata
      // body.mode === RequestBodyModes.urlencoded
      // should we add default CONTENT-TYPE Header `application/x-www-form-urlencoded`?

      var params = []
      bodyData.each(function (paramItem) {
        params.push(util.format('%s=%s', encodeURIComponent(paramItem.key), encodeURIComponent(paramItem.value)))
      })

      data = params.join('&')
    }
  }

  return Helper.buildK6Request({
    url: url,
    method: method,
    headers: headers,
    data: data,
    preRequest: preRequest,
    postRequest: postRequest,
    variable: 'res'
  })
}

function moduleExist (name) {
  try { return require(name) } catch (e) { return false }
}

module.exports = K6Generator
